extends /layouts/default

block vars
  - var page = "developer";
  - const github = "https://github.com/crisbal/Telegram-Bot-Node";
  - const repoName = github.split("/")[4];

block content
  include /includes/navbar
  
  .container
    section.section
      .columns
        .column.is-3
          aside.menu
            p.menu-label Developer's guide
            ul.menu-list
              li: a(href="#architecture") Architecture
              li
                a(href="#plugins") Plugins
                ul
                  li: a(href="#staticGetPlugin"): tt static get plugin()
                  li: a(href="#constructor"): tt constructor(obj)
                  li: a(href="#getCommands"): tt get commands()
                  li: a(href="#eventListeners") Event listeners
              li: a(href="#usingAPI") Using the Telegram API
              li: a(href="#proxy") Proxy plugins
              li: a(href="#auth") The Auth helper
        .column.is-9
          section#architecture
            h3.title Architecture
            p
              | This is an overview of the logic flow of messages:
            figure.has-text-centered
              a(href=root+"assets/images/Message_diagram.png", alt="Message flow diagram", title="Open this image in a new tab", target="_blank")
                img(src=root+"assets/images/Message_diagram.png")
            p.
              PluginManager receives Telegram messages, and passes them to the proxy plugins for inspection. If the message is approved by all proxies, it is sent to all plugins, which may decide to reply with a text, picture and so on by interacting directly with the Telegram API.
          section#plugins
            h3.title Plugins
            p.
              In #{projectname}, plugins are #[strong classes that react to specific events from the Telegram API].
            p.
              The general structure is:
            pre: code.js.
              // File: src/plugins/MyPlugin.js
              const Plugin = require("../Plugin");

              module.exports = class MyPlugin extends Plugin {
                // Information about your plugin.
                static get plugin() {
                  return {
                    name: "MyPlugin",
                    description: "It does things.",
                    help: "Try saying 'Hello!', or using the /hello command."
                  }
                }

                // Optional: initialize the plugin.
                constructor(obj) {
                  super(obj);

                  /* ... */
                }

                // Optional: stop the plugin.
                stop() {
                  foo.stop();
                }

                // An object, mapping commands to their handlers.
                // Handlers can return a string, representing a text reply.
                get commands() {
                  return {
                    hello: ({args, message}) => {
                      // Args is an array of arguments passed by the user (eg. `/foo bar` would have args = ["bar"])
                      // Message is the message that triggered the handler

                      return "Heyo!";
                  };
                }

                // Alternatively, you can use the more verbose onCommand listener.
                onCommand({message, command, args}) {
                  if (command === "hello") {
                    this.sendMessage(message.chat.id, "Heyo!");
                  }
                }

                // Called when a message is received.
                onText({message}) {
                  if (message === "Hello!") {
                    this.sendMessage(message.chat.id, "Hi!");
                  }
                }

                onPhoto({message}) {
                  /* ... */
                }

                /* ... */
              }
            p.
              As you can see, it is a class that extends Plugin (from #[tt src/Plugin.js]). The metadata is given through #[tt static get plugin()], which #[strong must] be present.
            blockquote#staticGetPlugin
              | Every plugin must have #[tt static get plugin()], which returns an object. At a minimum, it contains:
              ul.list
                li #[tt name]: the plugin's name
                li #[tt description]: a short description (shown in the list of plugins)
                li #[tt help]: a help text (shown in #[kbd /help PluginName])
              | It can include additional properties, which we'll explain later:
              ul.list
                li #[tt isProxy], which says whether this plugin has proxy capabilities or not (default: false)
                li #[tt isHidden], which says whether this plugin is hidden from #[kbd /help] or not (default: false)
            p.
              It optionally features a #[tt constructor], to give you access to rarely-used objects:
            blockquote#constructor
              | #[tt constructor] gets passed a single variable (usually called #[tt obj]), which contains the objects needed to initialize the plugin. They are:
              ul.list
                li config: the bot's configuration
                li auth: an instance of the Auth helper, documented later
              | There are also some properties you shouldn't need:
              ul.list
                li db: the plugin database loaded from disk (you shouldn't need it, it's in #[tt this.db])
                li blacklist: same as above, but with the blacklist (#[tt this.blacklist])
                li emitter: the emitter from PluginManager (can be accessed with #[tt onText], #[tt onMessage] and so on)
                li bot: the TelegramBot object from #[tt node-telegram-bot-api]
            p.
              Most of the time, it features a list of commands, in a special shorthand form (#[tt command:&nbsp;({message,&nbsp;args})&nbsp;=&gt;&nbsp;reply]) that allows for concise code.
            blockquote#getCommands
              | To use the commands shorthand, add a #[tt commands] getter:
              pre: code.js.
                get commands() {
                  return {
                    commandName: ({message, args}) => {
                      // Your code here
                    },
                    ping: ({message, args}) => "Pong!"                  
                  }
                }
              | It returns an object, where each key is the command name and the value is the handler. It takes an object with #[tt message] being the Telegram message, and #[tt args] being an array of arguments.
              blockquote
                strong Note that #[tt args] is just "the rest of the message, split with spaces", so it can have unpredictable results when you expect strings.
                br
                | For instance, if the original message is #[kbd /echo Hello world!], #[tt args] will be #[tt ["Hello", "world!"]] and #[strong not] #[tt ["Hello world!"]].
              | If the handler returns a string, it is sent to the chat where the message came from. This can be useful to avoid going through the cumbersome Telegram API. For example:
              pre: code.js.
                get commands() {
                  return {
                    reverseText: ({message, args}) => {
                      const text = args.join(" "); // Because there may be multiple words
                      if (text === "")
                        return "Please give me some text to reverse.";
                      const reversed = text.split("").reverse().join(""); // https://stackoverflow.com/a/959004
                      return reversed;
                    }
                  }
                }
            p.
              It also features one or more #[strong event listeners], functions that react to events.
            blockquote#eventListeners
              | An example of event listener is:
              pre: code.js.
                onText({message}) {
                  // Your code here
                }
              p They are functions that are invoked whenever a specific event happens. They take an object argument with the property #[tt message]; the return value is ignored.
              p You can reply to the message using the Telegram API methods, documented below.
              p You can find a list of event listeners in #[tt src/Plugins.js]; the general rule is that the listener takes the name of the event (text -> onText, photo -> onPhoto and so on).
          section#usingAPI
            h3.title Using the Telegram API
            p.
              #{projectname} exposes the Telegram API through #[tt: a(href="https://npmjs.com/package/node-telegram-bot-api") node-telegram-bot-api], the methods of which are bound on the Plugin instance. In short, this means that inside a plugin you can simply call #[tt this.sendMessage(...)] and it will work as expected.
            blockquote.
              Note that in #[tt function() { }] blocks, #[tt this] #[strong does not] point to the Plugin instance, so #[tt this.sendMessage] won't work as expected. You should replace them with arrow functions if you wish to use #[tt this].
            p.
              Refer to the #[a(href="https://github.com/yagop/node-telegram-bot-api/blob/release/doc/api.md") NTBA reference] or its #[a(href="https://github.com/yagop/node-telegram-bot-api#usage") documentation] for extended information on how to use it. Here are some of the most common cases:
            pre: code.js.
              // Responding to a message
              onText({message}) {
                if (message.text === "Hello, bot!") {
                  this.sendMessage(message.chat.id, "Hello, user!");
                }
              }

              // Italic/bold text
              onText({message}) {
                this.sendMessage(message.chat.id, "__Italic__, **bold**", {parse_mode: "Markdown"});
                this.sendMessage(message.chat.id, "&lt;i&gt;Italic&lt;/i&gt;, &lt;b&gt;bold&lt;/b&gt;", {parse_mode: "HTML"});
              }

              // Sending a picture
              onText({message}) {
                this.sendPhoto(message.chat.id, "/home/john/Pictures/paveldurov.jpg", {caption: "This is Pavel Durov."});
              }
            blockquote.
              Note that #[tt sendMessage] (like all send* functions) takes two arguments, the chat ID (or the user ID, if they already initiated a conversation with the bot) and the text.
          section#proxy
            h3.title Proxy plugins
            p.
              #{projectname} supports #[i proxy plugins], i.e. plugins that can approve or reject messages. Approved messages keep going through the bot and plugins; rejected messages are dropped.
            p.
              To configure a plugin as a proxy, simply set #[tt isProxy: true] in #[tt static get plugin()] and implement a #[tt proxy(eventName, message)] method. It will receive every message, returning a rejected Promise (#[tt Promise.reject]) if the message is rejected, and anything else otherwise.
          section#auth
            h3.title The Auth helper
            p.
              Sometimes, you may want to restrict the usage of a command to mods, or viceversa you may want to apply a command differently for normal users and admins (eg. prevent admins from being kicked). For this, you can use the Auth helper, which has methods to determine whether a user is a mod or an admin in a specific chat. You can get it via the constructor:
            pre: code.js.
              constructor(obj) {
                super(obj);

                this.auth = obj.auth;
              }

              onText({message}) {
                if (this.auth.isAdmin(message.chat.id, message.from.id)) {
                  this.sendMessage(message.chat.id, "You are an admin!");
                } else {
                  this.sendMessage(message.chat.id, "You are not an admin, sorry.");                
                }
              }
            p.
              It exposes the methods #[tt isMod(chatID, userID)] and #[tt isAdmin(chatID, userID)] to determine whether an user is #[strong at least] a mod or an admin in a chat, #[tt isGlobalAdmin(userID)] to determine if the user is a global admin (i.e. a founder) per #[tt config.json], and #[tt getMods(chatID)]/#[tt getAdmins(chatID)] to get an array of mod and admin user IDs respectively.
